# HTTP课程

## 一、协议

### 1.1 什么是协议

协议是指计算机通信网络中两台计算机之间进行通信所必须共同遵守的规定或规则。不同厂商的设备、不同的CPU以及不同的操作系统组成的计算机之间，只要遵守相同的协议就能够实现通信

### 1.2 协议的分层

- ISO提出了作为通信协议设计指标的OSI参考模型，这个模型把通信协议中必要的功能分为了7层。同一层之间的交互所遵循的约定叫做'协议'。
- 协议分层就像计算机中的模块化开发，通过分层能够细分通信功能，更易于单独实现每个分层的协议，并界定各个分层的具体责任和义务。

### 1.3 OSI参考模型

![oyriM4.png](https://s4.ax1x.com/2021/12/06/oyriM4.png)

#### 1.3.1 应用层

针对特定应用的协议，为应用程序提供服务并规定应用程序中通信的相关细节。包括文件传输、电子邮件、远程登录等协议。

#### 1.3.2 表示层

将应用处理的信息转换为适合网络传输的格式，或将来自下一层的数据转换为上层能够处理的格式。因此它主要负责数据格式的转换。

具体来说就是把设备固有的数据格式转换为网络标准传输格式

#### 1.3.3 会话层

负责决定建立和断开通信连接，以及数据的分割等数据传输相关的管理。（采用那种连接进行发送）

#### 1.3.4 传输层

会话层负责决定建立连接和断开连接的时机，而传输层进行实际的建立和断开处理，并且起着可靠传输的作用。

#### 1.3.5 网络层

将数据传输到目标地址。目标地址可以是多个网络通过路由器连接而成的某个地址。因此这一层主要负责寻址和路由选择

#### 1.3.6 **数据链路层**

负责物理层上的互联、节点之间的通信传输。

#### 1.3.7 物理层

负责0、1比特流（0、1序列）与电压的高低、光的闪灭之间的互换





## 二、 TCP/IP协议

### 2.1 含义

字面意思理解，可能会被理解为TCP和IP两种协议。但是在很多情况下它只是利用IP进行通信时所必须用到的协议群的总称。

具体来说，IP或者TCP或者FTP或者HTTP等都是属于TCP/IP协议的内容，因此有时也称TCP/IP为网际协议族

### 2.2 TCP/IP协议分层模型

TCP/IP的各种协议其实是可以应对到OSI参考模型中。

![oy2qfI.png](https://s4.ax1x.com/2021/12/07/oy2qfI.png)

#### 2.2.1 应用层

应用层决定了向用户提供应用服务时通信的活动，FTP、DNS、HTTP协议都在这一层

#### 2.2.2 传输层

传输层提供处理网络连接中两台计算机之间的数据传输，在传输层有两种性质的协议 TCP（传输控制协议）和UDP（用户数据报协议）

#### 2.2.3 网络层

网络层用来处理网络上流动的数据包，该层规定了通过怎样的路径到达对方计算机，在众多选项内选择一条传输路线，ip协议在这一层

#### 2.2.4 链路层（网络接口层）

用来处理网络的硬件部分，包括硬件驱动，NIC，光纤等物理可见部分

![oyfnY9.png](https://s4.ax1x.com/2021/12/07/oyfnY9.png)

## 三、HTTP协议简介

### 3.1 HTTP协议是什么

- **Hyper Text Transfer Protocol（超文本传输协议）**,是用于从万维网（WWW:World Wide Web ）服务器传输超文本到本地浏览器的传送协议。是互联网上应用最为广泛的一种网络协议。所有的 WWW 文件都必须遵守这个标准。
- 客户端与服务端通信时传输的内容我们称之为报文。
- HTTP就是一个通信规则，这个规则规定了客户端发送给服务器的报文格式，也规定了服务器发送给客户端的报文格式。实际我们要学习的就是这两种报文。客户端发送给服务器的称为“请求报文”，服务器发送给客户端的称为“响应报文”。

### 3.2 什么是HTTP报文

- 它是HTTP应用程序之间发送的数据块。这些数据块以一些文本形式的元信息开头，这些信息描述了报文的内容及含义，后面跟着可选的数据部分。这些报文都是在客户端、服务器和代理之间流动。
- **HTTP报文的流动方向：**一次HTTP请求，HTTP报文会从“客户端”流到“代理”再流到“服务器”，在服务器工作完成之后，报文又会从“服务器”流到“代理”再流到“客户端”
- **报文的语法：**所有的HTTP报文都可以分为两类，**请求报文和响应报文**。请求和响应报文的基本报文结构大致是相同的，只有起始行的语法有所不同。
  - **请求报文：**它会向Web服务器请求一个动作
  - **响应报文：**它会将请求的结果返回给客户端。

### 3.3 浏览器查看network

#### 3.3.1 响应的内容

![](https://tva1.sinaimg.cn/large/00831rSTly1gcw5y1yyjuj315k0fy3zb.jpg)

- Headers:报文的头部

- Preview:预览响应的数据

- Response:响应的具体数据

- Initiator:初始化内容

- Timing：时间

- Cookies:携带的cookie

#### 3.3.2 响应头的内容

![](https://tva1.sinaimg.cn/large/00831rSTly1gcw64ze0g0j30b804cq2s.jpg)

- General:通用头部

- Response Headers:响应头部


- Request Headers:请求头部



### 3.4 报文包

![](https://tva1.sinaimg.cn/large/00831rSTly1gcx3mvo963j31hu0gstcv.jpg)

#### 3.4.1 请求报文包

##### 3.4.1.1 GET请求报文包

1. 请求报文首行

   - GET http://localhost:3000/?name=lily HTTP/1.1
   - GET 请求方式是GET（其他的方式：GET(查) POST(增)PUT(上传文件)DELETE(删除)OPTIONS(跨域请求)）
   - http://localhost:3000/ 请求服务器地址
   - HTTP/1.1 HTTP协议/1.1版本
   - ?name=lily :请求参数，也叫查询字符串（query String）

2. 请求报文头部  

   - Host: localhost:3000  访问服务器的主机名

   - Connection: keep-alive  保持长链接（保持TCP连接）实际上它是一种TCP复用，每次http请求都需要tcp三次握手，浪费资源和时间，因此我们可以保持tcp通道连接一段时间，这样一次tcp连接就可以维持几次http请求

   - Cache-Control: max-age=0  缓存

   - Upgrade-Insecure-Requests: 1  允许https协议

   - User-Agent: Mozilla/5.0 (Windows NT 10.0; Win64; x64) AppleWebKit/537.36 (KHTML, like Gecko) Chrome/80.0.3987.122 Safari/537.36  用户代理：客户端信息通过User-Agent来区分浏览器

   - Accept:text/html,application/xhtml+xml,application/xml;q=0.9,image/webp,image/apng,*/*;q=0.8,application/signed-exchange;v=b3;q=0.9代表客户端允许接收的文件类型
   - Accept-Encoding: gzip, deflate, br 代表客户端允许接收文件的压缩格式
   - Accept-Language: zh-CN,zh;q=0.9  代表客户端支持语言
   - Cookie: _ga=GA1.1.444464845.1583242232  cookie 会话控制

3. 请求报文空行

4. 请求报文体

   POST请求的请求数据 （GET请求会在请求首行中）




##### 3.4.1.2 POST请求报文包

1. 请求报文首行

   POST http://localhost:3000/ HTTP/1.1

2. 请求报文头部

   - Host: localhost:3000
   - Connection: keep-alive
   - Content-Length: 28
   - Cache-Control: max-age=0
   - Origin: http://localhost:52330
   - Upgrade-Insecure-Requests: 1
   - Content-Type: application/x-www-form-urlencoded form表单提交的数据

3. 请求体类型

   - User-Agent: Mozilla/5.0 (Windows NT 10.0; Win64; x64) AppleWebKit/537.36 (KHTML, like Gecko) Chrome/80.0.3987.122 Safari/537.36
   - Sec-Fetch-Dest: document
   - Accept: text/html,application/xhtml+xml,application/xml;q=0.9,image/webp,image/apng,*/*;q=0.8,application/signed-exchange;v=b3;q=0.9
   - Sec-Fetch-Site: same-site
   - Sec-Fetch-Mode: navigate
   - Sec-Fetch-User: ?1
   - Referer: http://localhost:52330/03.nodejs/day03/form.html
   - Accept-Encoding: gzip, deflate, br
   - Accept-Language: zh-CN,zh;q=0.9
   - Cookie: _ga=GA1.1.444464845.1583242232

4. 空行

5. 请求报文体

   username=aaaa&password=bbbbb

#### 3.4.2 响应报文包

1. 响应报文首行

   - HTTP/1.1 200 OK（原因短语）
     - HTTP/1.1 协议名/版本号

     - 200 响应状态码

     - OK 响应信息
2. 响应报文头部

   - Content-Type: text/html;charset=utf8
     - 响应体类型

   - Date: Fri, 06 Mar 2020 05:51:45 GMT
     - 响应时间

   - Connection: keep-alive

   - Content-Length: 25
     - 响应体长度
3. 空行
4. 响应报文体

### 3.5 HTTPS

#### 3.5.1 HTTP缺点

- 通信使用明文，内容可能被窃听
  - 加密处理防止被窃听，http没有加密机制，但是可以通过和SSL或者TLS组合使用进行加密HTTP的内容
- 不验证通信方的身份就可能遭遇伪装
  - SSL可以确认通信方，提供了一种叫做证书的手段，用于确认通信方
- 无法确认报文的完整性，可能已经遭遇篡改
  - SSL可以提供完整性的保护

#### 3.5.2 HTTPS

- HTTP+加密+认证+完整性保护 = HTTPS。

- 经常会在登录和购物清算页面使用HTTPS通信，协议变成了https://

- 另外当浏览器访问https://的网站时，地址栏会显示一个锁的标志



## 四、重要报文

### 4.1 Content-Type

`Content-Type`实体头部用于指示资源的MIME类型。

在响应中，Content-Type标头告诉客户端实际返回的内容的内容类型。

MIME类型也叫媒体类型，是一种标准，用来表示文档、文件或字节流的性质和格式。

重要的MIME类型：

| MIME类型                              | 含义                                 |
| ------------------------------------- | ------------------------------------ |
| **application/octet-stream**          | **应用程序文件**                     |
| **text/plain**                        | **文本文件**                         |
| **text/css**                          | **css**文件                          |
| **text/html**                         | **html**文件                         |
| **application/javascript**            | **js**文件                           |
| **image/gif**                         | **GIF** **图片**                     |
| **image/jpeg**                        | **JPEG/JPG** **图片**                |
| **image/png**                         | **PNG** **图片**                     |
| **image/svg+xml**                     | **SVG**图片 (矢量图)                 |
| **image/x-icon**                      | **icon**图片                         |
| **application/json**                  | **json**文件                         |
| **multipart/form-data**               | 上传文件                             |
| **application/x-www-form-urlencoded** | Form表单格式                         |
| **audio/webm**                        | **WebM** **音频文件格式**            |
| **video/webm**                        | **WebM****视频文件格式的音视频文件** |



### 4.2 响应状态码 status

HTTP 响应状态代码（status）指示特定 HTTP 请求是否已成功完成。响应分为五类：

- 信息响应(100–199)：接受的请求正在处理

- 成功响应(200–299)：请求正常处理完毕
  - 200: 请求成功。
  - 201: Created 表示请求已经被成功处理，并且创建了新的资源。这通常是在POST请求，或是某些PUT请求之后返回的响应
  - **204 No Content** 该状态码表示服务器接收的请求已成功处理，但在返回的响应报文中不含实体的主体部分。比如，当从浏览器发出请求处理后，返回204响应，那么浏览器显示的页面不发生更新，一般只需要客户端向服务端发送消息，而不要新内容的时候发生
- 重定向(300–399)
  - 301: Moved Permanently， 永久性重定向。该状态码表示请求的资源已经被分配了新的URI，以后应使用资源现在所指的URI
  - **302 Found** 临时性重定向。该状态码表示请求的资源已被分配了新的URI，希望用户(本次)能使用新的URI访问。
  - **304 Not Modified** 请求资源未被修改，浏览器将会读取缓存
- 客户端错误(400–499)
  - **400 Bad Request** 该状态码表示请求报文中存在语法错误。当错误发生时，需要修改请求的内容后再次发送请求。
  - **401 Unauthorized** 该状态码表示发送的请求需要有通过HTTP认证的认证信息，另外若之前已进行过1此请求，则表示用户认证失败。
  - **403 Forbidden** 该状态码表明对请求资源的访问被服务器拒绝了，服务端没有必要给出拒绝理由
  - **404 Not Found** 该状态码表明服务器上无法找到请求的资源。除此之外，也可以在服务器端拒绝请求且不想说明理由时使用。
- 服务器错误 (500–599)。
  - **500 Internal Server Error** 该状态码表明服务器端在执行请求时发生了错误。
  - **503 Service Unavailable** 该状态码表明服务器暂时处于超负载或正在进行停机维护，现在无法处理请求



## 五、请求方式

### 5.1 请求方式

- GET请求

  发送请求来获得服务器上的资源，请求体中不会包含请求数据，请求数据放在协议头中

- POST请求

  和GET一样很常见，向服务器提交资源让服务器处理，比如提交表单、上传文件等，可能导致建立新的资源或者对原有资源的修改。提交的资源放在请求体中。

- PUT请求

  和post类似，html表单不支持，向指定资源位置上传其最新内容（主要是传输文件）

- DELETE请求

  请求服务器删除某资源

- HEAD请求

  本质和get一样，但是响应中没有呈现数据，而是http的头信息，主要用来检查资源或超链接的有效性或是否可以到达

- OPTIONS请求

  获取http服务器支持的http请求方法，比如ajax跨域时的预检等。

### 5.2 GET和POST的区别

1. get是获取数据的，而post是提交数据的。
2. GET 可缓存， 而POST 不可缓存。
3. post发送的数据更大，get有url长度限制
4. post能发送更多的数据类型（get只能发送ASCII字符）



## 六、相关面试题

### 6.1 三次握手

#### 6.1.1 什么是三次握手

- TCP是一种面向连接的单播协议，在发送数据前，通信双方必须在彼此间建立一条连接。所谓的“连接”，其实是客户端和服务器的内存里保存的一份关于对方的信息，如ip地址、端口号等。

- 所谓三次握手(Three-way Handshake)，是指建立一个TCP连接时，需要客户端和服务器总共发送3个数据包，ACK：确认有效，确认序号。SYN：发起一个新连接。

<img src="https://tva1.sinaimg.cn/large/00831rSTly1gcxdw1ieruj30u00vfmza.jpg" style="zoom:50%;" />

#### 6.1.2 为什么要三次握手

客户端和服务端通信前要进行连接，“3次握手”的作用就是双方都能明确自己和对方的收、发能力是正常的。

第一次握手：客户端发送网络包，服务端收到了。这样服务端就能得出结论：客户端的发送能力、服务端的接收能力是正常的。

第二次握手：服务端发包，客户端收到了。这样客户端就能得出结论：服务端的接收、发送能力，客户端的接收、发送能力是正常的。 从客户端的视角来看，我接到了服务端发送过来的响应数据包，说明服务端接收到了我在第一次握手时发送的网络包，并且成功发送了响应数据包，这就说明，服务端的接收、发送能力正常。而另一方面，我收到了服务端的响应数据包，说明我第一次发送的网络包成功到达服务端，这样，我自己的发送和接收能力也是正常的。

第三次握手：客户端发包，服务端收到了。这样服务端就能得出结论：客户端的接收、发送能力，服务端的发送、接收能力是正常的。 第一、二次握手后，服务端并不知道客户端的接收能力以及自己的发送能力是否正常。而在第三次握手时，服务端收到了客户端对第二次握手作的回应。从服务端的角度，我在第二次握手时的响应数据发送出去了，客户端接收到了。所以，我的发送能力是正常的。而客户端的接收能力也是正常的。

经历了上面的三次握手过程，客户端和服务端都确认了自己的接收、发送能力是正常的。之后就可以正常通信了



### 6.2 四次挥手

TCP的连接的拆除需要发送四个包，因此称为四次挥手(four-way handshake)。客户端或服务器均可主动发起挥手动作。

Fin：释放连接

ACK：确认有效，确认序号。

SYN：发起一个新连接。

Seq: 序号。

TCP 是双向的，所以需要在两个方向分别关闭，每个方向的关闭又需要请求和确认，所以一共就4次。

![](https://tva1.sinaimg.cn/large/00831rSTly1gcxe17p0koj30ve0lcdix.jpg)

### 6.3 浏览器渲染流程

1. 构建 DOM 树

   - 因为浏览器无法直接理解和使用 html 文件，所以需要将 html 文件转为浏览器能够理解的结构 DOM 树
   - 输入：html 文件
   - 输出：DOM 树
   - 操作过程：解析 html 结构为浏览器可以理解的 DOM 树结构，期间会去下载次级资源以及执行 js 代码。

2. 样式计算

   样式计算是为了获取每个节点的样式，其主要分为三步来完成。

   - 转成浏览器可以理解的数据结构styleSheets，可以在开发者工具上通过 document.styleSheets 打印出来。只需要了解到主进程会将 css 代码转成浏览器可以理解的结构，这个结构支持查询和修改。可以在开发者工具上通过 document.styleSheets 打印出来。

   - 将 css 转成标准化的样式

     比如 rem 转成 px、bule 转成 rgba 等。

   - 最后是计算每个节点的样式。

     这一步骤涉及到 css 的继承规则和层叠规则。有些属性是可以被子元素继承的，有些属性是会覆盖前面的样式

3. 布局阶段

   想要渲染一个完整的页面，仅知道 DOM 树和 DOM 树元素的样式还是不够的，我们还需要知道 DOM 树中元素的位置。同样的布局这个子阶段也分为两个过程操作，分别是合成布局树和计算节点位置。

   - 合成布局树

     布局树和 DOM 树类似，不过布局树上只包含会显示的节点内容，不包含 display: none 样式的元素。只包含可见节点

   - 计算节点位置

     有了一颗完成的布局树，主线程会计算出每个元素的位置信息以及盒子大小

4. 分层

   因为页面有很多复杂的效果，比如滑动、z-idnex 等。为了更好的实现这些效果，渲染引擎**主线程**还需要为特定的阶段生成专用的图层，并生成一颗对应的**图层树**。

   - 拥有层叠上下文属性的元素会单独生成一个图层。

     - 3D 或透视变换的 css 属性
     - 使用加速视频解码的 video 元素
     - canvas 元素
     - opacity 属性

   - 需要裁剪的地方也会单独生成一个图层

     裁剪就是需要滚动的地方，里面内容会单独生成一个图层。如果有滚动条，滚动条也会单独生成一个图层

5. 图层绘制

   在完成图层树的构建之后，渲染引擎**主线程**会对每个图层进行绘制。这里说的绘制不是真正的绘制画面，而是生成一个绘制指令列表。

   将每个图层的绘制拆分成多个绘制指令，传给**合成线程**。

6. 栅格化

   绘制指令生成之后，渲染进程**主线程**会将绘制指令发送给**合成线程**，由合成线程来完成最后的绘制工作。合成线程会将图层划分为**图块**。

7. 合成和显示

   等所有图块都被栅格化，**合成线程**会收集位图信息来创建**合成帧**。合成帧随后会通过 IPC 协议将消息传给**浏览器主进程**。浏览器主进程收到消息后，会将页面内容绘制到内存中，最后再将内存显示在屏幕上。

   ![](https://tva1.sinaimg.cn/large/00831rSTly1gcxdow0t7sj30w20ds3zh.jpg)

### 6.4 从url输入到最后展示的过程

1. DNS查询 / 解析

   - 将域名地址解析成ip地址
2. TCP连接： TCP三次握手

3. 发送请求

   按照HTTP协议的规定，生成请求报文，浏览器将请求报文发送给服务器

   浏览器将请求报文发送给服务器

4. 返回响应

   按照HTTP协议的规定，生成相应报文，服务器将请求报文发送给客户端

5. 渲染页面

6. 断开连接：TCP四次挥手

